Chapter 1: Introduction to Hibernate
1.1. What is Hibernate
1.2  Why use Hibernate
1.3. ORM basics
1.4. Advantages over JDBC.

============================================================
1.1 What is Hibernate?
------------------------------------------------------------
• Hibernate is an open-source Object-Relational Mapping (ORM) framework for Java.

• Hibernate acts as a bridge between Java applications and the database,
  automatically converting object operations into SQL queries.

• Hibernate simplifies the process of building Java applications that interact with relational databases.

• Hibernate maps Java classes to database tables  and handles the underlying SQL operations,
  helping developers to work directly with high-level Java objects.
------------------------------------------------------------
1.2 Why Use Hibernate?
------------------------------------------------------------
Hibernate helps in overcoming the limitations of traditional JDBC programming by offering the following advantages:

1. Ease of Use       : Hides the complexity of database operations,
                       allowing developers to work with Java objects
                       instead of writing SQL queries.

2. Productivity      : Reduces repetitive boilerplate code, speeding up development.

3. Portability       : Works with multiple databases and makes switching between them easy.

4. Performance       : Provides built-in caching and optimization mechanisms.

5. Maintainability   : Database schema changes require minimal code modifications.

6. Scalability       : Efficiently handles large-scale, high-transaction applications.
                       Works with standalone apps and large scale web-apps(enterprise apps) easily

These features help developers focus on business logic rather than database connectivity.

---------------------------------------------------
1.3 ORM basics
ORM maps object-oriented concepts (classes, objects) to relational tables and columns.
	•	ORM Eliminates mismatch between Java objects and relational databases.
	•	ORM Automatically converts Java objects to database records and vice versa.
	•	ORM Reduces need for repetitive SQL operations like INSERT, UPDATE, DELETE.
	•	Hibernate is one of the most popular ORM implementations in Java.
------------------------------------------------------------
1.5. JDBC vs Hibernate Comparison
------------------------------------------------------------
The following table highlights key differences between JDBC and Hibernate ORM:

-------------------------------------------------------------------------------------------------------------
 Feature/Aspect               |                 JDBC                           |               Hibernate
-------------------------------------------------------------------------------------------------------------
 1. API Level & SQL Handling  | Requires manual SQL coding and ResultSet       | Abstracts SQL using ORM, allowing
                              | handling.                                      | object-based operations.
-------------------------------------------------------------------------------------------------------------
 2. Database Independence     | Tightly coupled with specific database syntax. | Database-independent through dialects.
-------------------------------------------------------------------------------------------------------------
 3. Object Mapping            | No object mapping; developer must manually     | Automatically maps Java classes to
                              | handle object-to-table mapping.                | database tables.
-------------------------------------------------------------------------------------------------------------
 4. Transaction Management    | Managed manually using Connection and SQL      | Built-in transaction management with
                              | statements.                                    | declarative support.
-------------------------------------------------------------------------------------------------------------
 5. Caching                   | No built-in caching; every query hits the DB.  | Supports first-level and second-level
                              |                                                | caching to improve performance.
-------------------------------------------------------------------------------------------------------------
 6. Lazy Loading              | Not supported; all data must be fetched        | Supported; data is fetched only when
                              | manually.                                      | accessed, reducing load time.
-------------------------------------------------------------------------------------------------------------
 7. Eager Loading             | Not supported; must be implemented manually.   | Supported; associated data is loaded
                              |                                                | immediately when required.
-------------------------------------------------------------------------------------------------------------
 8. Schema Generation         | Database schema must be created manually       | Can automatically generate schema
                              | using SQL scripts.                             | based on mapping files or annotations.
-------------------------------------------------------------------------------------------------------------
 9. Maintenance               | High maintenance due to manual SQL and         | Easier maintenance using annotations
                              | code changes when schema evolves.              | and XML-based configuration.
-------------------------------------------------------------------------------------------------------------
10. Performance Tuning        | Requires manual optimization and SQL tuning.   | Built-in tuning via caching, fetching,
                              |                                                | and batching strategies.
-------------------------------------------------------------------------------------------------------------
11. Batch Processing          | Supported but requires explicit coding.        | Supported and simpler through APIs.
-------------------------------------------------------------------------------------------------------------
12. Tooling                   | Limited to basic JDBC libraries.               | Offers advanced ORM tools like
                              |                                                | Hibernate Validator, Envers, etc.
-------------------------------------------------------------------------------------------------------------

Interview Questions
1. What is Hibernate, and
   how does it help Java applications interact with a relational database?

2. Why do developers prefer Hibernate over writing plain JDBC code?
   Mention at least three reasons.

3. What is ORM, and how does Hibernate use
   ORM to map Java objects to database tables?

4. Can you explain the object–relational impedance mismatch?
   How does Hibernate solve it?

5. How does Hibernate improve productivity compared to JDBC?
   Give practical examples.

6. What are the main differences between JDBC and Hibernate?
   Can you explain at least five key differences?
